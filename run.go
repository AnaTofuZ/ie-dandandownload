package dandandowlonad

import (
	"bufio"
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"runtime"
	"strings"
	"sync"
)

//DanDownload is struct
type DanDownload struct {
	urlsfilePath string
}

//NewDanDownload is constracutor
func NewDanDownload(urlfilePath string) *DanDownload {
	return &DanDownload{
		urlsfilePath: urlfilePath,
	}
}

func (d *DanDownload) Run2() int {
	di := newDonloadInfo()
	info, err := d.getURLLists2()
	if err != nil {
		fmt.Println(err)
		return 1
	}

	wg := &sync.WaitGroup{}
	cpus := runtime.NumCPU()
	semaphore := make(chan bool, cpus)
	ctx := context.Background()

	for _, eachInfo := range info.Img {
		wg.Add(1)
		go func(ctx context.Context, e EachInfo) {
			defer wg.Done()
			semaphore <- true
			err := di.exec2(ctx, e.URL, e.FilePATH, e.OutputDir)
			if err != nil {
				fmt.Println(err)
			}
			<-semaphore
		}(ctx, eachInfo)
	}
	wg.Wait()
	for _, eachInfo := range *&info.Files {
		wg.Add(1)
		go func(ctx context.Context, e EachInfo) {
			defer wg.Done()
			semaphore <- true
			err := di.exec2(ctx, e.URL, e.FilePATH, e.OutputDir)
			if err != nil {
				fmt.Println(err)
			}
			<-semaphore
		}(ctx, eachInfo)
	}
	wg.Wait()
	for _, eachInfo := range *&info.CSS {
		wg.Add(1)
		go func(ctx context.Context, e EachInfo) {
			defer wg.Done()
			semaphore <- true
			err := di.exec2(ctx, e.URL, e.FilePATH, e.OutputDir)
			if err != nil {
				fmt.Println(err)
			}
			<-semaphore
		}(ctx, eachInfo)
	}
	wg.Wait()
	return 0
}

func (d *DanDownload) Run() int {
	di := newDonloadInfo()
	urls, err := d.getURLLists()
	if err != nil {
		fmt.Println(err)
		return 1
	}

	wg := &sync.WaitGroup{}
	cpus := runtime.NumCPU()
	semaphore := make(chan bool, cpus)
	ctx := context.Background()

	for _, url := range *urls {
		wg.Add(1)
		go func(ctx context.Context, url string) {
			defer wg.Done()
			semaphore <- true
			err := di.exec(ctx, url)
			if err != nil {
				fmt.Println(err)
			}
			<-semaphore
		}(ctx, url)
	}
	wg.Wait()
	return 0
}

func (d *DanDownload) getURLLists() (*[]string, error) {
	f, err := os.Open(d.urlsfilePath)
	if err != nil {
		return nil, err
	}
	scanner := bufio.NewScanner(f)
	urls := make([]string, 0, 700)
	var sbuilder strings.Builder
	for scanner.Scan() {
		sbuilder.WriteString("https://ie.u-ryukyu.ac.jp/")
		sbuilder.WriteString(scanner.Text())
		urls = append(urls, sbuilder.String())
		sbuilder.Reset()
	}
	return &urls, nil
}

type EachInfo struct {
	URL       string `json:"url"`
	FilePATH  string `json:"filePATH"`
	OutputDir string `json:"outputDir"`
}

type AutoGenerated struct {
	Files []EachInfo `json:"files"`
	Img   []EachInfo `json:"img"`
	CSS   []EachInfo `json:"css"`
}

func (d *DanDownload) getURLLists2() (*AutoGenerated, error) {
	f, err := os.Open(d.urlsfilePath)
	if err != nil {
		return nil, err
	}
	plan, err := ioutil.ReadAll(f)

	var data AutoGenerated

	err = json.Unmarshal(plan, &data)

	if err != nil {
		return nil, err
	}

	return &data, nil
}
